Index: backend/src/main/java/com/TesisUrbe/backend/Users/Services/UserService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tesisUrbe.backend.users.services;\r\n\r\nimport com.tesisUrbe.backend.users.dto.NewUserDto;\r\nimport com.tesisUrbe.backend.users.dto.RoleUpdateDto;\r\nimport com.tesisUrbe.backend.users.dto.UpdateUserDto;\r\nimport com.tesisUrbe.backend.users.dto.UserDto;\r\nimport com.tesisUrbe.backend.users.enums.RoleList;\r\nimport com.tesisUrbe.backend.users.exceptions.RoleNotFoundException;\r\nimport com.tesisUrbe.backend.users.exceptions.UserAlreadyExistsException;\r\nimport com.tesisUrbe.backend.users.model.Role;\r\nimport com.tesisUrbe.backend.users.model.User;\r\nimport com.tesisUrbe.backend.users.repository.UserRepository;\r\nimport org.springframework.dao.DataIntegrityViolationException;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.security.access.AccessDeniedException;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Service\r\npublic class UserService implements UserDetailsService {\r\n\r\n    private final UserRepository userRepository;\r\n    private final RoleService roleService;\r\n    private final PasswordEncoder passwordEncoder;\r\n\r\n    public UserService(UserRepository userRepository, RoleService roleService, PasswordEncoder passwordEncoder) {\r\n        this.userRepository = userRepository;\r\n        this.roleService = roleService;\r\n        this.passwordEncoder = passwordEncoder;\r\n    }\r\n\r\n    @Transactional\r\n    public void registerUser(NewUserDto newUserDto, Authentication authentication) {\r\n\r\n        if (existByUserName(newUserDto.getUserName())) {\r\n            throw new UserAlreadyExistsException(\"El nombre de usuario ya existe\");\r\n        }\r\n\r\n        if (existByEmail(newUserDto.getEmail())) {\r\n            throw new UserAlreadyExistsException(\"El correo electrónico ya está registrado\");\r\n        }\r\n\r\n        try {\r\n            RoleList requestedRole = RoleList.valueOf(\r\n                    newUserDto.getRole() != null ? newUserDto.getRole() : \"ROLE_USER\"\r\n            );\r\n\r\n            if (requestedRole == RoleList.ROLE_SUPERUSER) {\r\n                accessSuperUser(authentication);\r\n            }\r\n\r\n            if (requestedRole == RoleList.ROLE_ADMIN) {\r\n                accessAdmin(authentication);\r\n            }\r\n\r\n            Role role = roleService.findByName(requestedRole)\r\n                    .orElseThrow(() -> new RoleNotFoundException(\"Rol no encontrado\"));\r\n\r\n            User user = new User(\r\n                    newUserDto.getUserName(),\r\n                    passwordEncoder.encode(newUserDto.getPassword()),\r\n                    newUserDto.getEmail(),\r\n                    role\r\n            );\r\n\r\n            user.setActive(true);\r\n            userRepository.save(user);\r\n\r\n        } catch (IllegalArgumentException e) {\r\n            throw new RoleNotFoundException(\"Rol inválido\");\r\n        } catch (DataIntegrityViolationException e) {\r\n            throw new UserAlreadyExistsException(\"El correo electrónico o nombre de usuario ya está registrado\");\r\n        }\r\n    }\r\n\r\n    public void save(User user) {\r\n        userRepository.save(user);\r\n    }\r\n\r\n    @Override\r\n    public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {\r\n        User user = userRepository.findOptionalUserByUserName(userName)\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"Usuario no encontrado\"));\r\n        SimpleGrantedAuthority authority = new SimpleGrantedAuthority(user.getRole().getName().name());\r\n\r\n        return new org.springframework.security.core.userdetails.User(\r\n                user.getUserName(),\r\n                user.getPassword(),\r\n                Collections.singletonList(authority)\r\n        );\r\n    }\r\n\r\n    public User findByUserName(String userName) {\r\n        return userRepository.findByUserName(userName);\r\n    }\r\n\r\n    public List<UserDto> findAll(Authentication authentication) {\r\n        checkAuthentication(authentication);\r\n\r\n        User requester = userRepository.findOptionalUserByUserName(authentication.getName())\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"Usuario autenticado no encontrado\"));\r\n\r\n        RoleList requesterRole = requester.getRole().getName();\r\n\r\n        if (requesterRole == RoleList.ROLE_USER) {\r\n            throw new AccessDeniedException(\"No tienes permiso para consultar todos los usuarios\");\r\n        }\r\n\r\n        List<User> usuarios = userRepository.findAll();\r\n\r\n        if (usuarios.isEmpty()) {\r\n            throw new UsernameNotFoundException(\"No hay usuarios registrados\");\r\n        }\r\n\r\n        List<User> filtrados = usuarios.stream()\r\n                .filter(user -> {\r\n                    RoleList targetRole = user.getRole().getName();\r\n                    if (requesterRole == RoleList.ROLE_ADMIN) {\r\n                        return targetRole == RoleList.ROLE_USER || targetRole == RoleList.ROLE_ADMIN;\r\n                    }\r\n                    return true;\r\n                })\r\n                .toList();\r\n\r\n        return filtrados.stream()\r\n                .map(user -> new UserDto(\r\n                        user.getId(),\r\n                        user.getUserName(),\r\n                        user.getEmail(),\r\n                        user.getRole().getName().name(),\r\n                        user.isActive(),\r\n                        user.isVerified(),\r\n                        user.isBlocked()\r\n                ))\r\n                .toList();\r\n    }\r\n\r\n    public UserDto findById(Long id, Authentication authentication) {\r\n        User targetUser = ownerOrSuperior(id, authentication);\r\n        return new UserDto(\r\n                targetUser.getId(),\r\n                targetUser.getUserName(),\r\n                targetUser.getEmail(),\r\n                targetUser.getRole().getName().name(),\r\n                targetUser.isActive(),\r\n                targetUser.isVerified(),\r\n                targetUser.isBlocked()\r\n        );\r\n    }\r\n\r\n    public void updateUser(Long userId, UpdateUserDto updateUserDto, Authentication authentication) {\r\n\r\n        User user = ownerOrSuperior(userId, authentication);\r\n\r\n        if (existByUserName(updateUserDto.getUserName()) &&\r\n                !user.getUserName().equals(updateUserDto.getUserName())) {\r\n            throw new IllegalArgumentException(\"Nombre de usuario ya está en uso\");\r\n        }\r\n\r\n        if (existByEmail(updateUserDto.getEmail()) &&\r\n                !user.getEmail().equals(updateUserDto.getEmail())) {\r\n            throw new IllegalArgumentException(\"Correo electrónico ya está en uso\");\r\n        }\r\n\r\n        if (updateUserDto.getRole() != null) {\r\n            RoleList requestedRole = updateUserDto.getRole().getName();\r\n            if (requestedRole == RoleList.ROLE_SUPERUSER) {\r\n                accessSuperUser(authentication);\r\n            }\r\n            if (requestedRole == RoleList.ROLE_ADMIN) {\r\n                accessAdmin(authentication);\r\n            }\r\n            Role role = roleService.findByName(requestedRole)\r\n                    .orElseThrow(() -> new RoleNotFoundException(\"Rol no encontrado\"));\r\n            user.setRole(role);\r\n        }\r\n        user.setUserName(updateUserDto.getUserName());\r\n        user.setEmail(updateUserDto.getEmail());\r\n        user.setPassword(passwordEncoder.encode(updateUserDto.getPassword()));\r\n        try {\r\n            userRepository.save(user);\r\n        } catch (DataIntegrityViolationException e) {\r\n            throw new IllegalArgumentException(\r\n                    \"Error al actualizar el usuario. Posiblemente el correo o nombre de usuario ya estén registrados.\"\r\n            );\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Ocurrió un error inesperado al actualizar el usuario.\", e);\r\n        }\r\n\r\n    }\r\n\r\n    public void updateRoleById(\r\n            Long userId,\r\n            RoleUpdateDto roleUpdateDto,\r\n            Authentication authentication\r\n    ) {\r\n\r\n        try {\r\n            accessAdmin(authentication);\r\n            RoleList requestedRole = RoleList.valueOf(roleUpdateDto.getRoleName());\r\n            Optional<Role> optionalRole = roleService.findByName(requestedRole);\r\n\r\n            Role role = optionalRole.orElseThrow(() ->\r\n                    new RoleNotFoundException(\"Rol no encontrado: \" + roleUpdateDto.getRoleName())\r\n            );\r\n\r\n            User user = userRepository.findById(userId)\r\n                    .orElseThrow(() -> new UsernameNotFoundException(\"Usuario no encontrado\"));\r\n            if (user.getRole().getName() == requestedRole) {\r\n                throw new IllegalArgumentException(\"El usuario ya tiene el rol especificado\");\r\n            }\r\n\r\n            if (requestedRole.name().equals(RoleList.ROLE_SUPERUSER.toString())\r\n                    || user.getRole().getName() == RoleList.ROLE_SUPERUSER\r\n            ){\r\n                accessSuperUser(authentication);\r\n            }\r\n\r\n            user.setRole(role);\r\n            save(user);\r\n\r\n        } catch (IllegalArgumentException e) {\r\n            throw new IllegalArgumentException(\"Nombre de rol inválido: \" + roleUpdateDto.getRoleName(), e);\r\n        } catch (DataIntegrityViolationException e) {\r\n            throw new RuntimeException(\"Error al actualizar el rol del usuario. Posible conflicto de datos.\", e);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Ocurrió un error inesperado al actualizar el rol.\", e);\r\n        }\r\n    }\r\n\r\n\r\n    public boolean isActive(Long id) {\r\n        return userRepository.isActive(id);\r\n    }\r\n\r\n    public boolean isBlocked(Long id) {\r\n        return userRepository.isBlocked(id);\r\n    }\r\n\r\n    public boolean isVerified(Long id) {\r\n        return userRepository.isVerified(id);\r\n    }\r\n\r\n    public boolean existByEmail(String email) {\r\n        return userRepository.existsByEmail(email);\r\n    }\r\n\r\n    public boolean existByUserName(String userName) {\r\n        return userRepository.existsByUserName(userName);\r\n    }\r\n\r\n    public void blockUser(Long userId) {\r\n        User user = userRepository.findById(userId)\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"Usuario no encontrado\"));\r\n        user.setBlocked(true);\r\n        save(user);\r\n        userRepository.save(user);\r\n    }\r\n\r\n    public void deactivateUserById(Long id, Authentication authentication ) {\r\n        User user = ownerOrSuperior(id, authentication);\r\n        userRepository.DeactivateUser(id);\r\n\r\n    }\r\n\r\n    public void reactivateUserById(Long id, Authentication authentication){\r\n        accessAdmin(authentication);\r\n        User user = userRepository.findById(id)\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"Usuario no encontrado\"));\r\n        userRepository.ReactivateUser(id);\r\n    }\r\n\r\n    private void accessSuperUser(Authentication authentication) {\r\n        checkAuthentication(authentication);\r\n        if (authentication.getAuthorities().stream().noneMatch(\r\n                a -> a.getAuthority().equals(\"ROLE_SUPERUSER\")\r\n        )) {\r\n            throw new AccessDeniedException(\"Solo un Super Usuario tiene permiso para realizar esta acción\");\r\n        }\r\n    }\r\n\r\n    private void accessAdmin(Authentication authentication) {\r\n        checkAuthentication(authentication);\r\n        if (authentication.getAuthorities().stream().noneMatch(\r\n                a ->\r\n                        a.getAuthority().equals(\"ROLE_SUPERUSER\") || a.getAuthority().equals(\"ROLE_ADMIN\")\r\n        )){\r\n            throw new AccessDeniedException(\r\n                    \"Solo un Administrador o Super Usuario tiene permiso para realizar esta acción\"\r\n            );\r\n        }\r\n\r\n    }\r\n\r\n    private User ownerOrSuperior(Long id, Authentication authentication){\r\n        checkAuthentication(authentication);\r\n\r\n        User requester = userRepository.findOptionalUserByUserName(authentication.getName())\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"Usuario autenticado no encontrado\"));\r\n\r\n        User targetUser = userRepository.findById(id)\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"Usuario solicitado no encontrado\"));\r\n\r\n        RoleList requesterRole = requester.getRole().getName();\r\n        RoleList targetRole = targetUser.getRole().getName();\r\n\r\n        if (requesterRole != RoleList.ROLE_USER &&\r\n                requesterRole != RoleList.ROLE_ADMIN &&\r\n                requesterRole != RoleList.ROLE_SUPERUSER) {\r\n            throw new AccessDeniedException(\"Rol no reconocido\");\r\n        }\r\n\r\n        if (requesterRole == RoleList.ROLE_USER &&\r\n                !requester.getId().equals(targetUser.getId())) {\r\n            throw new AccessDeniedException(\"No tienes permiso para interactuar con esta cuenta\");\r\n        }\r\n\r\n        if (requesterRole == RoleList.ROLE_ADMIN &&\r\n                targetRole == RoleList.ROLE_SUPERUSER) {\r\n            throw new AccessDeniedException(\"No tienes permiso para interactuar con un Super Usuario\");\r\n        }\r\n\r\n        return targetUser;\r\n    }\r\n\r\n    private void checkAuthentication(Authentication authentication){\r\n        if (authentication == null) {\r\n            throw new AccessDeniedException(\"No autenticado\");\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/src/main/java/com/TesisUrbe/backend/Users/Services/UserService.java b/backend/src/main/java/com/TesisUrbe/backend/Users/Services/UserService.java
--- a/backend/src/main/java/com/TesisUrbe/backend/Users/Services/UserService.java	(revision 0b3345445a4b4289c36bfe051de2745b6c793128)
+++ b/backend/src/main/java/com/TesisUrbe/backend/Users/Services/UserService.java	(date 1756079944744)
@@ -221,13 +221,14 @@
 
             if (requestedRole.name().equals(RoleList.ROLE_SUPERUSER.toString())
                     || user.getRole().getName() == RoleList.ROLE_SUPERUSER
-            ){
+            ) {
                 accessSuperUser(authentication);
             }
 
             user.setRole(role);
             save(user);
-
+        } catch (AccessDeniedException e){
+            throw e;
         } catch (IllegalArgumentException e) {
             throw new IllegalArgumentException("Nombre de rol inválido: " + roleUpdateDto.getRoleName(), e);
         } catch (DataIntegrityViolationException e) {
